package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/charmbracelet/huh"
	"github.com/charmbracelet/huh/spinner"
	"github.com/charmbracelet/lipgloss"
)

// DockerStack holds configuration for the Docker development environment
type DockerStack struct {
	WebServer     string   // Apache or Nginx
	Database      string   // PostgreSQL or MySQL
	ProjectName   string   // Project name for container prefixing
	WebPort       string   // Port for web server
	DbPort        string   // Port for database
	PhpVersion    string   // PHP version
	HostUID       string   // Host user ID for file permissions
	HostGID       string   // Host group ID for file permissions
}

var (
	highlight = lipgloss.NewStyle().
			Foreground(lipgloss.Color("212")).
			Bold(true)

	subtle = lipgloss.NewStyle().
		Foreground(lipgloss.Color("241"))

	headerStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("86")).
			Bold(true).
			MarginTop(1)

	errorStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("161")).
			Bold(true)

	// Define the confirm variable here
	confirm bool
)

// Helper functions to replace ternary operators
func getDbConnection(database string) string {
	if strings.ToLower(database) == "postgresql" {
		return "pgsql"
	}
	return "mysql"
}

func getDbPort(database string) string {
	if database == "PostgreSQL" {
		return "5432"
	}
	return "3306"
}

// getDefaultUID returns the current user's UID
func getDefaultUID() string {
	cmd := exec.Command("id", "-u")
	output, err := cmd.Output()
	if err != nil {
		return "1000" // Default if command fails
	}
	return strings.TrimSpace(string(output))
}

// getDefaultGID returns the current user's GID
func getDefaultGID() string {
	cmd := exec.Command("id", "-g")
	output, err := cmd.Output()
	if err != nil {
		return "1000" // Default if command fails
	}
	return strings.TrimSpace(string(output))
}

// generateDockerFiles creates all needed Docker configuration files
func generateDockerFiles(config DockerStack) error {
	// Create directory structure
	err := os.MkdirAll("docker", 0755)
	if err != nil {
		return fmt.Errorf("failed to create docker directory: %w", err)
	}

	// Create .env file or update existing
	envContent := fmt.Sprintf(`# Generated by Docker Stack TUI on %s
# This file contains developer-specific settings
# DO NOT COMMIT THIS FILE TO VERSION CONTROL

# Laravel environment settings
APP_NAME=%s
APP_ENV=local
APP_KEY=
APP_DEBUG=true
APP_URL=http://localhost:%s

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

# Database settings
DB_CONNECTION=%s
DB_HOST=db
DB_PORT=%s
DB_DATABASE=laravel
DB_USERNAME=laravel
DB_PASSWORD=secret

# Docker settings
PROJECT_NAME=%s
WEB_PORT=%s
DB_PORT=%s
HOST_UID=%s
HOST_GID=%s
`,
		time.Now().Format("2006-01-02 15:04:05"),
		config.ProjectName,
		config.WebPort,
		getDbConnection(config.Database),
		getDbPort(config.Database),
		config.ProjectName,
		config.WebPort,
		config.DbPort,
		config.HostUID,
		config.HostGID)

	// Check if .env exists
	if _, err := os.Stat(".env"); os.IsNotExist(err) {
		// Create new .env file
		err = os.WriteFile(".env", []byte(envContent), 0644)
		if err != nil {
			return fmt.Errorf("failed to create .env file: %w", err)
		}
	} else {
		// Make a backup of existing .env file
		backupFile := ".env.backup-" + time.Now().Format("20060102150405")
		input, err := os.ReadFile(".env")
		if err == nil {
			err = os.WriteFile(backupFile, input, 0644)
			if err != nil {
				fmt.Println(subtle.Render("Could not create backup of .env file"))
			} else {
				fmt.Println(subtle.Render("Created backup of existing .env file: " + backupFile))
			}
		}

		// Update .env file
		err = os.WriteFile(".env", []byte(envContent), 0644)
		if err != nil {
			return fmt.Errorf("failed to update .env file: %w", err)
		}
	}

	// Generate Dockerfile
	dockerfileTemplate := `FROM php:{{.PhpVersion}}{{if eq .WebServer "Apache"}}-apache{{else}}-fpm{{end}}

ARG UID=${HOST_UID}
ARG GID=${HOST_GID}

# Modify existing www-data user and group to match host UID and GID
RUN usermod -u ${UID} www-data && \
    groupmod -g ${GID} www-data

# Install system dependencies and PHP extensions
RUN apt-get update && apt-get install -y \
    git \
    curl \
    zip \
    unzip \
    libpng-dev \
    libjpeg-dev \
    libfreetype6-dev \
    libzip-dev \
    libicu-dev \
    libxslt-dev \
    libpq-dev \
    libonig-dev \
    libxml2-dev \
    && docker-php-ext-configure gd --with-freetype --with-jpeg \
    && docker-php-ext-install -j$(nproc) \
        gd \
        pdo \
        {{if eq .Database "PostgreSQL"}}pdo_pgsql{{else}}pdo_mysql{{end}} \
        intl \
        mbstring \
        xml \
        zip \
        bcmath \
        sockets \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Install Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

{{if eq .WebServer "Apache"}}
# Configure Apache
WORKDIR /var/www/html
RUN a2enmod rewrite
ENV APACHE_DOCUMENT_ROOT /var/www/html/public
RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf
RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf
{{else}}
# PHP-FPM Configuration
WORKDIR /var/www
{{end}}

# Set permissions
RUN chown -R www-data:www-data {{if eq .WebServer "Apache"}}/var/www/html{{else}}/var/www{{end}} \
    && chmod -R 775 {{if eq .WebServer "Apache"}}/var/www/html{{else}}/var/www{{end}}

# We don't copy application code or install dependencies here
# because we'll mount the code as a volume

USER www-data

# These ensure Laravel runs in development mode
ENV APP_ENV=local
ENV APP_DEBUG=true`

	// Create Dockerfile template
	tmpl, err := template.New("dockerfile").Parse(dockerfileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse Dockerfile template: %w", err)
	}

	// Create Dockerfile
	dockerFile, err := os.Create("docker/Dockerfile")
	if err != nil {
		return fmt.Errorf("failed to create Dockerfile: %w", err)
	}
	defer dockerFile.Close()

	err = tmpl.Execute(dockerFile, config)
	if err != nil {
		return fmt.Errorf("failed to generate Dockerfile: %w", err)
	}

	// Generate docker-compose.yml
	composeTemplate := `version: '3'

services:
  {{if eq .WebServer "Nginx"}}
  web:
    image: nginx:alpine
    volumes:
      - ./:/var/www
      - ./docker/nginx.conf:/etc/nginx/conf.d/default.conf
    ports:
      - "${WEB_PORT}:80"
    networks:
      - app_network
    environment:
      - APP_ENV=local
    depends_on:
      - app
    restart: unless-stopped

  app:
    build:
      context: .
      dockerfile: docker/Dockerfile
      args:
        UID: ${HOST_UID}
        GID: ${HOST_GID}
    volumes:
      - ./:/var/www
    networks:
      - app_network
    environment:
      - APP_ENV=local
      - APP_DEBUG=true
      - DB_CONNECTION={{if eq .Database "PostgreSQL"}}pgsql{{else}}mysql{{end}}
      - DB_HOST=db
      - DB_PORT={{if eq .Database "PostgreSQL"}}5432{{else}}3306{{end}}
      - DB_DATABASE=${DB_DATABASE}
      - DB_USERNAME=${DB_USERNAME}
      - DB_PASSWORD=${DB_PASSWORD}
    restart: unless-stopped
    depends_on:
      - db
  {{else}}
  web:
    build:
      context: .
      dockerfile: docker/Dockerfile
      args:
        UID: ${HOST_UID}
        GID: ${HOST_GID}
    volumes:
      - ./:/var/www/html
    ports:
      - "${WEB_PORT}:80"
    networks:
      - app_network
    environment:
      - APP_ENV=local
      - APP_DEBUG=true
      - DB_CONNECTION={{if eq .Database "PostgreSQL"}}pgsql{{else}}mysql{{end}}
      - DB_HOST=db
      - DB_PORT={{if eq .Database "PostgreSQL"}}5432{{else}}3306{{end}}
      - DB_DATABASE=${DB_DATABASE}
      - DB_USERNAME=${DB_USERNAME}
      - DB_PASSWORD=${DB_PASSWORD}
    restart: unless-stopped
    depends_on:
      - db
  {{end}}

  db:
    {{if eq .Database "PostgreSQL"}}
    image: postgres:latest
    environment:
      POSTGRES_DB: ${DB_DATABASE}
      POSTGRES_USER: ${DB_USERNAME}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - db_data:/var/lib/postgresql/data
    {{else}}
    image: mysql:8
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_USER: ${DB_USERNAME}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
    volumes:
      - db_data:/var/lib/mysql
    {{end}}
    ports:
      - "${DB_PORT}:{{if eq .Database "PostgreSQL"}}5432{{else}}3306{{end}}"
    networks:
      - app_network
    restart: unless-stopped

networks:
  app_network:
    driver: bridge

volumes:
  db_data:
    driver: local
`

	// Create docker-compose.yml template
	tmpl, err = template.New("docker-compose").Parse(composeTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse docker-compose template: %w", err)
	}

	// Create docker-compose.yml
	composeFile, err := os.Create("docker-compose.yml")
	if err != nil {
		return fmt.Errorf("failed to create docker-compose.yml: %w", err)
	}
	defer composeFile.Close()

	err = tmpl.Execute(composeFile, config)
	if err != nil {
		return fmt.Errorf("failed to generate docker-compose.yml: %w", err)
	}

	// Create Nginx configuration if needed
	if config.WebServer == "Nginx" {
		nginxConf := `server {
    listen 80;
    server_name localhost;

    root /var/www/public;
    index index.php index.html;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        include fastcgi_params;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

    location ~ /\.ht {
        deny all;
    }
}`
		err = os.WriteFile("docker/nginx.conf", []byte(nginxConf), 0644)
		if err != nil {
			return fmt.Errorf("failed to create nginx.conf: %w", err)
		}
	}

	// Create .gitignore if it doesn't exist or append to it
	gitignoreContent := `
# Docker developer-specific files
.env
docker-compose.override.yml
`
	// Check if .gitignore exists
	if _, err := os.Stat(".gitignore"); os.IsNotExist(err) {
		// Create new .gitignore file
		err = os.WriteFile(".gitignore", []byte(gitignoreContent), 0644)
		if err != nil {
			return fmt.Errorf("failed to create .gitignore file: %w", err)
		}
	} else {
		// Append to existing .gitignore file
		f, err := os.OpenFile(".gitignore", os.O_APPEND|os.O_WRONLY, 0644)
		if err != nil {
			return fmt.Errorf("failed to open .gitignore file: %w", err)
		}
		defer f.Close()

		_, err = f.WriteString(gitignoreContent)
		if err != nil {
			return fmt.Errorf("failed to update .gitignore file: %w", err)
		}
	}

	return nil
}

func main() {
	var stack DockerStack
	accessible := false

	// Set default values
	stack.HostUID = getDefaultUID()
	stack.HostGID = getDefaultGID()
	stack.WebPort = "8080"
	stack.DbPort = "5432"
	stack.ProjectName = filepath.Base(getCurrentDirectory())
	stack.PhpVersion = "8.3"

	// Main form for Docker stack selection
	stackForm := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Options(
					huh.NewOption("Apache 🌐", "Apache"),
					huh.NewOption("Nginx 🚀", "Nginx"),
				).
				Title("Choose Web Server").
				Description("Select your preferred web server").
				Value(&stack.WebServer),

			huh.NewSelect[string]().
				Options(
					huh.NewOption("PostgreSQL 🐘", "PostgreSQL"),
					huh.NewOption("MySQL 🐬", "MySQL"),
				).
				Title("Choose Database").
				Description("Select your preferred database").
				Value(&stack.Database),
		),

		huh.NewGroup(
			huh.NewInput().
				Title("Project Name").
				Description("Used for container naming").
				Value(&stack.ProjectName).
				Validate(func(s string) error {
					if s == "" {
						return fmt.Errorf("project name cannot be empty")
					}
					return nil
				}),

			huh.NewInput().
				Title("Web Port").
				Description("Port to expose for web server (default: 8080)").
				Value(&stack.WebPort).
				Validate(func(s string) error {
					if s == "" {
						return fmt.Errorf("web port cannot be empty")
					}
					return nil
				}),

			huh.NewInput().
				Title("Database Port").
				Description("Port to expose for database").
				Value(&stack.DbPort).
				Validate(func(s string) error {
					if s == "" {
						return fmt.Errorf("database port cannot be empty")
					}
					return nil
				}),

			huh.NewSelect[string]().
				Options(
					huh.NewOption("PHP 8.3", "8.3"),
					huh.NewOption("PHP 8.2", "8.2"),
					huh.NewOption("PHP 8.1", "8.1"),
				).
				Title("PHP Version").
				Description("Select PHP version").
				Value(&stack.PhpVersion),
		),

		huh.NewGroup(
			huh.NewConfirm().
				Title("Generate Docker Configuration?").
				Affirmative("Yes, let's go!").
				Negative("No, cancel").
				Value(&confirm),
		),
	).WithAccessible(accessible)

	err := stackForm.Run()
	if err != nil {
		fmt.Println(errorStyle.Render("Error: " + err.Error()))
		os.Exit(1)
	}

	if !confirm {
		fmt.Println(subtle.Render("Operation cancelled by user"))
		os.Exit(0)
	}

	// Show progress spinner
	generateFiles := func() {
		err := generateDockerFiles(stack)
		if err != nil {
			fmt.Println(errorStyle.Render("Error: " + err.Error()))
			os.Exit(1)
		}
	}

	_ = spinner.New().
		Title("Generating Docker configuration...").
		Accessible(accessible).
		Action(generateFiles).
		Run()

	// Print final summary
	{
		var sb strings.Builder
		fmt.Fprintf(&sb,
			"%s\n\nWeb Server: %s\nDatabase: %s\nProject: %s\nPHP Version: %s\nPorts: Web %s, DB %s",
			headerStyle.Render("DOCKER STACK SETUP COMPLETE"),
			highlight.Render(stack.WebServer),
			highlight.Render(stack.Database),
			highlight.Render(stack.ProjectName),
			highlight.Render(stack.PhpVersion),
			highlight.Render(stack.WebPort),
			highlight.Render(stack.DbPort),
		)

		// Add startup instructions
		fmt.Fprintf(&sb, "\n\n%s\n%s",
			headerStyle.Render("Next Steps:"),
			subtle.Render(fmt.Sprintf(`1. Run 'docker-compose up -d --build' to start your environment
2. Run 'docker exec %s-%s php artisan key:generate' to generate an app key
3. Run 'docker exec %s-%s php artisan migrate' to set up your database
4. Access your app at http://localhost:%s`,
				strings.ToLower(stack.ProjectName),
				strings.ToLower(func() string {
					if stack.WebServer == "Nginx" {
						return "app"
					}
					return "web"
				}()),
				strings.ToLower(stack.ProjectName),
				strings.ToLower(func() string {
					if stack.WebServer == "Nginx" {
						return "app"
					}
					return "web"
				}()),
				stack.WebPort)),
		)

		fmt.Println(
			lipgloss.NewStyle().
				Width(60).
				BorderStyle(lipgloss.RoundedBorder()).
				BorderForeground(lipgloss.Color("63")).
				Padding(1, 2).
				Render(sb.String()),
		)
	}
}

func getCurrentDirectory() string {
	dir, err := os.Getwd()
	if err != nil {
		return "laravel-project"
	}
	return dir
}
